1. Define and compare recursion and iteration. 
Recursion is a process performed by repeating the same steps until it is complete. The nature of recursion is to break down a problem into smaller problems. Iteration is best used when problems are solved utilizing loops. Recursive solutions do have their downfalls- they run slower, and are more subject to system limitations. Iterative solutions can be harder to implement in some cases.  Recursion should be used where iterative solutions are not possible. 

2. Name five algorithms that are commonly implemented by recursion. 

Fibonacci sequence, factorial of a number, greatest common divisor, recursive binary search, linked list print. 

3. When should you use recursion and when should you avoid recursion? 

Recursion is best used when you have a base case to stop the function from running indefinitely. A function can have more than one base case, but it depends on the algorithm. You never want to use recursion if you don't have at least one base case, otherwise it will NEVER end and will be like writing and running an infinite loop. 
Also if there is a way to use iteration instead, it would be better since iteration is better understood and more efficient. 

4. Compare the recursive and iterative solutions to the 3 algorithms from the checkpoint (Factorial, Maximum, and Fibonacci). What is similar and what is different? 

For each algorithm, it seems like there is a more efficient and easy to understand option. In Maximum, for example, the recursive solution can be quite long and removes one element from the array with each call, then has to find the biggest number in each of those calls/groups. In the iterative solution, we are simply taking one number and comparing it to the currentMaximum until the end is reached. The biggest thing that is similar in all of these, is that the end result is the same, but the process can be more or less efficient with the choices of iterative or recursive solutions. 

5. Given a multi-dimensional collection (such as an array) where the number of dimensions is unknown, write a recursive algorithm to count the number of items in the entire collection. 

function countElements(array){
  if(array.length){
    if(typeof array[0] === "object"){
      return countElements(array[0]) + countElements(array.slice(1));
    } else {
      return 1 +countElements(array.slice(1));
    }
  } else {
    return 0;
  }
}
	

6. A palindrome is a word or phrase whose spelling is the same either direction (e.g. racecar). Write a recursive algorithm to determine if a given word or phrase is a palindrome. 

function isPalindrome (string) {
	if (string.length <= 1){
		return true; 
  }
	else if (string.charAt(0) !== string.charAt(string.length-1)) {
		return false; 
  }
	else {
    if(string.charAt(0) === string.charAt(string.length-1)) {
    let slicedString= string.slice(1,-1); 
      console.log(slicedString); 
		return isPalindrome(slicedString); 
    }	
		return true; 
  }
}


7. Laura and Xander are going door to door around their block looking for their lost cat. Write a recursive algorithm showing one way they can visit every house on their block exactly once. 

const housesOnBlock = [{isCatHere: false},{isCatHere: false},{isCatHere: false},{isCatHere: true},{isCatHere: false},{isCatHere: false},{isCatHere: false},{isCatHere: false},{isCatHere: false},{isCatHere: false}];

function findCat (houses) {
  house= houses.pop(); 
  //if cat is in the house, return true
	if (house.isCatHere){
    return true; 
  }	 
  //if there is at least one more house to check, return the result 
	else {
    		if (houses.length > 0){
     		return findCat(houses); 
    		}
   		 return false; 
  	}
  }
			
		



	
		

